---
layout: post
title:  "JAWS Methodology in R"
subtitle: "August 19, 2016"
date:   2016-08-19 15:56:00 
categories: [articles]
---



## Introduction and Motivation

The ["Jaffe WARP Score system"](http://www.baseballprospectus.com/glossary/index.php?mode=viewstat&stat=477), aka JAWS, is a widely acknowledged sabermetric methodology for identifying Hall of Fame worthy players. It is simply defined as the average of the player's career WAR with their 'peak 7 year WAR.' This JAWS index is then compared to the average JAWS index of players already in the Hall of Fame, for that position. A player is deemed 'worthy' of the Hall of Fame if their JAWS index meets this threshold. 

This calculation seems very simple, but is not that easy to calculate efficiently and cleanly. This post goes through that process and explains, step-by-step, the R code necessary. I also share a bunch of tips and tricks that could greatly help your R workflow.

We're going to need a few packages, so install them if you haven't yet: `Lahman`, `dplyr`, `magrittr`, `readr`, and `ggplot2`.

## Data collection and exploration

First, we need to get data about these baseball players. Luckily, a number of R packages collect data about MLB players and make it easily accessible.

We use a package [`openWARData`](https://github.com/beanumber/openWARData), used as inputs to the Open WAR standard as our source of WAR information. This package collects WAR information from the leading WAR implementations, FanGraphs and Baseball Reference.[^1] For this post, we will only consider Baseball Reference WAR calculations.



Using that data, we can take a quick look at the underlying data.


```
## # A tibble: 18,850 x 5
##     playerId start_year end_year years_played total_war
##        <chr>      <int>    <int>        <int>     <dbl>
## 1  aardsda01       2004     2015            9      1.87
## 2  aaronha01       1954     1976           23    142.57
## 3  aaronto01       1962     1971            7     -2.79
## 4   aasedo01       1977     1990           13     15.26
## 5   abadan01       2001     2006            3     -0.36
## 6   abadfe01       2010     2016            8      2.32
## 7  abadijo01       1875     1875            2     -0.06
## 8  abbated01       1897     1910           10      8.59
## 9  abbeybe01       1892     1896            6      0.12
## 10 abbeych01       1893     1897            5      1.69
## # ... with 18,840 more rows
```

There's only so much data that we need here, however. We can narrow this down to get player-year pairs of rWAR. That is, the rWAR achieved by each player in each year. We also limit our dataset to include players who first appeared in the majors after 1900 to limit old-timey outliers.


```
## # A tibble: 93,077 x 3
##     playerId yearId  rWAR
##        <chr>  <int> <dbl>
## 1  aardsda01   2004 -0.14
## 2  aardsda01   2006  0.59
## 3  aardsda01   2007 -0.39
## 4  aardsda01   2008 -0.32
## 5  aardsda01   2009  1.75
## 6  aardsda01   2010  0.71
## 7  aardsda01   2012 -0.02
## 8  aardsda01   2013 -0.12
## 9  aardsda01   2015 -0.19
## 10 aaronha01   1954  1.27
## # ... with 93,067 more rows
```

## Part 1: JAWS Calculation

The first component of the JAWS method is the career WAR. We can easily visualize the distribution via the `ggplot2` package. The following commands are all we need to do, in English and translated into R:

1. Start with the above dataset `war_short`
2. Group by player, because we are concerned with the characteristics of each individual player 
3. Filter our dataset to only include those players with more than 7 years played.[^2]
4. Since we're at the individual level, we can sum up the WAR for each player.
5. Call ggplot2, and focus on the `total_war` variable
6. Create a histogram of the data
7. Cut the data off at 0 and 50 WAR, and 'squish' the results into range.
8. Label our axes and give the plot a title.



```r
war_career <- war_short %>% 
  group_by(playerId) %>%
  filter(n() >= 7) %>%
  summarize(total_war = round(sum(rWAR), 2))

war_career %>%
  ggplot(aes(total_war)) +
  geom_histogram() + 
  scale_x_continuous(limits = c(-5, 50), oob = scales::squish) +
  xlab("rWAR") + ylab("Count") + ggtitle("Distribution of Career WAR")
```

```
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

![plot of chunk unnamed-chunk-2](/figure/source/2016-08-19-jaws-in-r/unnamed-chunk-2-1.png)

This data looks like what we'd expect - a lot of players who have total WAR close to 0, denoting that they've performed at a replacement level, and a significant chunk of people who've earned more than 50 WAR. 

Calculating total career WAR is easy and quick, and might feel like a good metric to use overall. However, high performers according to career WAR require longevity in the major leagues, and punishes players who had a number of very good years, but not the longest career. JAWS attempts to correct for this by calculating peak WAR.

Our general process is as follows:

1. Begin with the same dataset as above 
2. Group by player and year, so even if a player is traded or went down to the minors, their season is counted as one.
3. For each player-year pairing, sum up the WAR for that year.
4. Ungroup and group by player instead, since we want to now 'move' across years.
5. We need to do a rolling window sum. This step is pretty tricky, so I go more into depth in the appendix.[^3] 
6. We group by player again and determine the highest peak WAR for each player.




```r
war_peak <- war_short %>%
  group_by(playerId, yearId) %>%
  summarize(rWAR = sum(rWAR)) %>%
  ungroup %>% group_by(playerId) %$%
  data.frame(playerId, yearId, 
             roll_war = slide_apply(data = rWAR, window = 7,
                                    fun = sum, na.rm = T)) %>%
  group_by(playerId) %>%
  summarize(peak_war = max(roll_war, na.rm = T))

war_peak
```

```
## # A tibble: 16,648 x 2
##     playerId peak_war
##       <fctr>    <dbl>
## 1  aardsda01     2.20
## 2  aaronha01    58.85
## 3  aaronto01    19.25
## 4   aasedo01    12.96
## 5   abadan01     2.27
## 6   abadfe01     2.32
## 7  abbotfr01     3.02
## 8  abbotgl01     6.15
## 9  abbotje01     4.12
## 10 abbotji01    22.64
## # ... with 16,638 more rows
```

We can take this data and plot the distribution of the peak WAR values. This distribution looks very similar to our above one, but with way fewer values that are out of bound to the right.


```
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
```

![plot of chunk unnamed-chunk-4](/figure/source/2016-08-19-jaws-in-r/unnamed-chunk-4-1.png)

Now, we have two data frames with career WAR and peak WAR. We can merge them by joining on player ID to get the following output:


```
## # A tibble: 5,497 x 3
##     playerId total_war peak_war
##        <chr>     <dbl>    <dbl>
## 1  aardsda01      1.87     2.20
## 2  aaronha01    142.57    58.85
## 3  aaronto01     -2.79    19.25
## 4   aasedo01     15.26    12.96
## 5   abadfe01      2.32     2.32
## 6  abbotgl01      5.67     6.15
## 7  abbotji01     19.88    22.64
## 8  abbotku01      0.57     4.83
## 9  abbotpa01      4.72     6.94
## 10  aberal01      0.61     4.88
## # ... with 5,487 more rows
```

Then, calculating the JAWS index is easy:


```
## # A tibble: 5,497 x 4
##     playerId total_war peak_war    JAWS
##        <chr>     <dbl>    <dbl>   <dbl>
## 1  aardsda01      1.87     2.20   2.035
## 2  aaronha01    142.57    58.85 100.710
## 3  aaronto01     -2.79    19.25   8.230
## 4   aasedo01     15.26    12.96  14.110
## 5   abadfe01      2.32     2.32   2.320
## 6  abbotgl01      5.67     6.15   5.910
## 7  abbotji01     19.88    22.64  21.260
## 8  abbotku01      0.57     4.83   2.700
## 9  abbotpa01      4.72     6.94   5.830
## 10  aberal01      0.61     4.88   2.745
## # ... with 5,487 more rows
```

## Part 2: Comparisons

Certain positions are known to emphasize defensive ability over offensive stats, which generally reduces their WAR numbers. Most commonly, teams consider the value of a shortstop or catcher to come from their defensive ability, not dropping pitches or covering a lot of ground acrobatically, rather than their bat. The flip side is that corner outfielders and first basemen have easier jobs, and so demand greater offensive output. 

The JAWS methodology accounts for position-wide disparities by comparing each player to only those Hall of Fame players who played the same position. We can try to do the same. 

The Lahman and Baseball Reference datasets don't provide us with a position label for each player, which makes sense because players often play different positions and often shift positions throughout their career. We do our best to classify each player here by calculating the number of games played by each player at each position, and then taking the position where they played the max.

1. We start with the `Lahman::Fielding` table, which includes fielding appearances by each player and the position at which they appeared.
1. We limit the number of columns to player, JAWS score, year, position, and games played
1. We group by the player and the positions they've played
1. We summarize by summing up the games played at each position.
1. We then group at the player level, and select only rows with the most games played at the position. In effect, we select the position most played.




```r
pos_data <- Lahman::Fielding %>%
  group_by(playerID, POS) %>%
  summarize(gp_pos = sum(G)) %>%
  group_by(playerID) %>%
  filter(gp_pos == max(gp_pos)) %>% 
  ungroup

war_pos <- war_merge %>% 
  left_join(pos_data, by = c("playerId" = "playerID"))

war_pos
```

```
## # A tibble: 5,507 x 6
##     playerId total_war peak_war    JAWS   POS gp_pos
##        <chr>     <dbl>    <dbl>   <dbl> <chr>  <int>
## 1  aardsda01      1.87     2.20   2.035     P    298
## 2  aaronha01    142.57    58.85 100.710    OF   2760
## 3  aaronto01     -2.79    19.25   8.230    1B    232
## 4   aasedo01     15.26    12.96  14.110     P    448
## 5   abadfe01      2.32     2.32   2.320     P    196
## 6  abbotgl01      5.67     6.15   5.910     P    248
## 7  abbotji01     19.88    22.64  21.260     P    263
## 8  abbotku01      0.57     4.83   2.700    SS    349
## 9  abbotpa01      4.72     6.94   5.830     P    162
## 10  aberal01      0.61     4.88   2.745     P    168
## # ... with 5,497 more rows
```

Now we want to know if a player was inducted into the Hall of Fame. First, we get the dataframe of Hall of Fame inductions. This uses the `Lahman::HallOfFame` table, which contains all votes for the Hall of Fame. Note that some players are not inducted, so we need to check if they've ever been inducted. In the data, the `inducted` variable shows up as 'Y' or 'N'; the easiest way to do this is to check if any instance of `inducted` for each player is 'Y'. 


```
## Observations: 4,088
## Variables: 9
## $ playerID    <chr> "cobbty01", "ruthba01", "wagneho01", "mathech01", ...
## $ yearID      <int> 1936, 1936, 1936, 1936, 1936, 1936, 1936, 1936, 19...
## $ votedBy     <chr> "BBWAA", "BBWAA", "BBWAA", "BBWAA", "BBWAA", "BBWA...
## $ ballots     <int> 226, 226, 226, 226, 226, 226, 226, 226, 226, 226, ...
## $ needed      <int> 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, ...
## $ votes       <int> 222, 215, 215, 205, 189, 146, 133, 111, 105, 80, 7...
## $ inducted    <fctr> Y, Y, Y, Y, Y, N, N, N, N, N, N, N, N, N, N, N, N...
## $ category    <fctr> Player, Player, Player, Player, Player, Player, P...
## $ needed_note <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA...
```


```r
hof <- Lahman::HallOfFame %>%
  group_by(playerID) %>%
  summarize(inducted = any(inducted == "Y"))
```

We can join this data against our above dataset to get our final table, with all the data we need.


```r
jaws_final <- war_pos %>% 
  left_join(hof, by = c("playerId" = "playerID")) %>%
  tidyr::replace_na(replace = list(inducted = F)) %>%
  select(playerId, JAWS:inducted)

jaws_final %>% head(10) %>% kable(round = 2)
```



|playerId  |    JAWS|POS | gp_pos|inducted |
|:---------|-------:|:---|------:|:--------|
|aardsda01 |   2.035|P   |    298|FALSE    |
|aaronha01 | 100.710|OF  |   2760|TRUE     |
|aaronto01 |   8.230|1B  |    232|FALSE    |
|aasedo01  |  14.110|P   |    448|FALSE    |
|abadfe01  |   2.320|P   |    196|FALSE    |
|abbotgl01 |   5.910|P   |    248|FALSE    |
|abbotji01 |  21.260|P   |    263|FALSE    |
|abbotku01 |   2.700|SS  |    349|FALSE    |
|abbotpa01 |   5.830|P   |    162|FALSE    |
|aberal01  |   2.745|P   |    168|FALSE    |

Now, we want to see the average for each position's Hall of Famers.


```r
jaws_hof <- jaws_final %>%
  filter(inducted == TRUE) %>%
  group_by(POS) %>%
  summarize(count = n(), avg = mean(JAWS))
jaws_hof %>% kable(round = 2)
```



|POS | count|      avg|
|:---|-----:|--------:|
|1B  |    16| 53.19875|
|2B  |    20| 48.69550|
|3B  |    11| 51.41682|
|C   |    13| 40.00962|
|DH  |     1| 55.55000|
|OF  |    53| 54.14349|
|P   |    54| 55.60278|
|SS  |    17| 47.19118|

## Conclusion

We've examined a real world 'sabermetric,' the JAWS index, and replicated its calculations in R.

How does our JAWS index compare to the listed Baseball Prospectus JAWS?


```
##    POS JAWS
## 1    C 42.6
## 2   1B 51.4
## 3   2B 53.8
## 4   3B 55.0
## 5   SS 50.7
## 6   LF 53.5
## 7   CF 58.3
## 8   RF 53.6
## 9   SP 43.5
## 10  RP 23.3
```

Our calculation is close. Some of the differences can be attributed to the above BP data being outdated (it was calculated in 2012), as well as possibly mislabelled player positions. 

## Appendix

[^1]: There is a lot of custom wrapper code here to make my life easier here. In particular, we use a wrapper around `read.csv` that saves downloaded files in a cache. This means, specifically, that I don't need to redownload functions every time I knit the document. However, you can replicate the basic functionality with the package, out of the box.
[^2]: Here, we don't bother grouping by year because we only want the total career WAR.
[^3]: This is a tricky step because we want to do a rolling sum on only the `rWAR` variable, and keep player ID and year intact. We have to use the `%$%` operator from the `magrittr` package in order to do so. For documentation, run `?%$%` in your R console, but this operator functions a lot like a `with` operator. It exposes the names of the left dataframe to the right, so we can run the rolling sum function for  I'm using a version of my [`slide_apply`](https://gist.github.com/stillmatic/fadfd3269b900e1fd7ee) function here, modified to return the sum of all elements if the player had fewer than 7 years. Note that we could skip that step if we filter for only players who've played at least 7 years. After we get the rolling sum, we need to reconstruct the data frame with the player ID and the year that they earned that 7-year cumulative value in. Constructing this dataframe alone isn't enough, since we need to re-add the grouping variable to do the next step.
